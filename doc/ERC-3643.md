# ERC-3643 (T-REX): Estructura y Funcionamiento

## ¿Qué es ERC-3643?

ERC-3643 (también conocido como **T-REX - Token for Regulated EXchanges**) es un estándar para **security tokens** que permite tokenizar activos reales (RWA - Real World Assets) con cumplimiento normativo on-chain. Asegura que solo usuarios verificados puedan recibir y transferir tokens, y permite aplicar reglas de compliance personalizables.

---

## Arquitectura del Estándar

ERC-3643 se estructura en **5 componentes principales** que trabajan juntos:

### 1. Token (Token Principal)

El contrato principal que extiende ERC-20 y añade funcionalidades de compliance:

**Características principales:**
- Extiende ERC-20 estándar
- Control de acceso basado en roles (Admin, Agent, Compliance)
- Integración con 3 registries (Identity, Trusted Issuers, Claim Topics)
- Sistema modular de compliance
- Pausable y congelación de cuentas

**Roles del sistema:**
- `DEFAULT_ADMIN_ROLE` - Configura registries, pausa token, gestiona roles
- `AGENT_ROLE` - Puede mintear, quemar, y realizar transferencias forzadas
- `COMPLIANCE_ROLE` - Puede agregar/remover módulos de compliance

### 2. Sistema de Identidad (Identity System)

Verifica que los usuarios cumplan requisitos antes de operar con tokens.

#### 2.1 Identity Contract

Cada usuario tiene un contrato de identidad que almacena **claims** (afirmaciones verificables):

```solidity
struct Claim {
    uint256 topic;      // Tipo de claim (ej: 1 = KYC)
    uint256 scheme;     // Esquema de firma
    address issuer;     // Quién emitió el claim
    bytes signature;    // Firma del claim
    bytes data;         // Datos del claim
    string uri;         // URI con información adicional
}
```

**Ejemplo:** Un claim puede ser "Usuario pasó KYC" emitido por un emisor confiable.

#### 2.2 IdentityRegistry

Mapea direcciones de wallet a sus contratos de identidad:

```solidity
mapping(address => Identity) private identities;
```

**Funciones principales:**
- `registerIdentity()` - Registra una identidad para un wallet
- `getIdentity()` - Obtiene el contrato de identidad de un wallet
- `isRegistered()` - Verifica si un wallet está registrado

#### 2.3 TrustedIssuersRegistry

Registra quién puede emitir claims válidos:

```solidity
mapping(address => uint256[]) private issuerClaimTopics;
mapping(address => bool) private trustedIssuers;
```

**Funciones principales:**
- `addTrustedIssuer()` - Agrega un emisor confiable
- `hasClaimTopic()` - Verifica si un emisor puede emitir un topic específico
- `getTrustedIssuers()` - Obtiene todos los emisores confiables

#### 2.4 ClaimTopicsRegistry

Define qué claims son obligatorios para ser considerado "verificado":

```solidity
uint256[] private claimTopics;
```

**Funciones principales:**
- `addClaimTopic()` - Agrega un topic requerido
- `getClaimTopics()` - Obtiene todos los topics requeridos
- `claimTopicExists()` - Verifica si un topic existe

---

## Flujo de Verificación de Identidad

Cuando un usuario intenta recibir tokens, el sistema verifica:

### Pasos de Verificación:

1. **¿Está registrado en IdentityRegistry?**
   - Verifica que el wallet tenga una identidad registrada

2. **¿Tiene un contrato Identity válido?**
   - Obtiene la dirección del contrato de identidad

3. **¿Tiene todos los claim topics requeridos?**
   - Obtiene la lista de topics requeridos desde ClaimTopicsRegistry

4. **¿Esos claims fueron emitidos por emisores confiables?**
   - Para cada topic requerido:
     - Busca emisores confiables que puedan emitir ese topic
     - Verifica que el Identity tenga ese claim de ese emisor

**Resultado:** Solo si TODOS los pasos pasan, el usuario está "verificado" y puede recibir/transferir tokens.

### Código de Verificación:

```solidity
function isVerified(address account) public view returns (bool) {
    // 1. Verificar que existe IdentityRegistry
    if (address(identityRegistry) == address(0)) {
        return false;
    }

    // 2. Verificar que está registrado
    if (!identityRegistry.isRegistered(account)) {
        return false;
    }

    // 3. Obtener contrato de identidad
    address identityAddress = identityRegistry.getIdentity(account);
    if (identityAddress == address(0)) {
        return false;
    }

    // 4. Obtener topics requeridos
    uint256[] memory requiredTopics = claimTopicsRegistry.getClaimTopics();

    // 5. Para cada topic requerido, verificar que existe claim válido
    for (uint256 i = 0; i < requiredTopics.length; i++) {
        bool hasValidClaim = false;

        // Buscar emisores confiables para este topic
        address[] memory trustedIssuers = trustedIssuersRegistry.getTrustedIssuers();

        for (uint256 j = 0; j < trustedIssuers.length; j++) {
            if (trustedIssuersRegistry.hasClaimTopic(trustedIssuers[j], requiredTopics[i])) {
                // Verificar que el claim existe en el Identity
                if (Identity(identityAddress).claimExists(requiredTopics[i], trustedIssuers[j])) {
                    hasValidClaim = true;
                    break;
                }
            }
        }

        if (!hasValidClaim) {
            return false;
        }
    }

    return true;
}
```

---

## Sistema de Compliance Modular

El token puede tener múltiples módulos de compliance que validan transferencias de forma independiente.

### Interfaz ICompliance

Todos los módulos deben implementar esta interfaz:

```solidity
interface ICompliance {
    // Verificar si una transferencia es compliant ANTES de ejecutarla
    function canTransfer(address from, address to, uint256 amount) 
        external view returns (bool);

    // Notificar DESPUÉS de que ocurrió una transferencia
    function transferred(address from, address to, uint256 amount) external;

    // Notificar cuando se mintean tokens
    function created(address to, uint256 amount) external;

    // Notificar cuando se queman tokens
    function destroyed(address from, uint256 amount) external;
}
```

### Ejemplo: MaxBalanceCompliance

Este módulo limita el balance máximo por wallet:

```solidity
function canTransfer(address, address to, uint256 amount) 
    external view override returns (bool) {
    // Obtener balance actual del destinatario
    uint256 recipientBalance = ERC20(tokenContract).balanceOf(to);
    
    // Verificar que no exceda el máximo
    return (recipientBalance + amount) <= maxBalance;
}
```

### Tipos de Módulos de Compliance

1. **MaxBalanceCompliance** - Limita tokens por wallet (default: 1000)
2. **MaxHoldersCompliance** - Limita número total de holders
3. **TransferLockCompliance** - Bloquea transferencias por período (default: 30 días)

---

## Flujo Completo de una Transferencia

Cuando un usuario intenta transferir tokens, se ejecuta el siguiente flujo:

### 1. Usuario llama `transfer(to, amount)`

### 2. Se ejecuta `_update()` (override de ERC-20)

```solidity
function _update(address from, address to, uint256 amount) 
    internal virtual override {
    // Validar ANTES de transferir
    if (from != address(0) && to != address(0) && !bypassCompliance) {
        require(canTransfer(from, to, amount), "Transfer not compliant");
    }

    // Ejecutar transferencia (actualizar balances)
    super._update(from, to, amount);

    // Notificar módulos DESPUÉS de transferir
    if (from != address(0) && to != address(0) && !bypassCompliance) {
        for (uint256 i = 0; i < complianceModules.length; i++) {
            complianceModules[i].transferred(from, to, amount);
        }
    }
}
```

### 3. `canTransfer()` ejecuta todas las validaciones

```solidity
function canTransfer(address from, address to, uint256 amount) 
    public view returns (bool) {
    // 1. ¿El token está pausado?
    if (paused()) {
        return false;
    }

    // 2. ¿Alguna cuenta está congelada?
    if (frozen[from] || frozen[to]) {
        return false;
    }

    // 3. ¿Ambas direcciones están verificadas?
    if (!isVerified(from) || !isVerified(to)) {
        return false;
    }

    // 4. ¿Todos los módulos de compliance aprueban?
    for (uint256 i = 0; i < complianceModules.length; i++) {
        if (!complianceModules[i].canTransfer(from, to, amount)) {
            return false;
        }
    }

    return true;
}
```

### Orden de Validación:

1. ✅ **Pausa global** - ¿El token está pausado?
2. ✅ **Cuentas congeladas** - ¿Alguna cuenta está congelada?
3. ✅ **Verificación de identidad** - ¿Ambas direcciones están verificadas?
4. ✅ **Módulos de compliance** - ¿Todos los módulos aprueban la transferencia?

**Si TODAS las validaciones pasan → Transferencia exitosa**

---

## Roles y Permisos

El token usa **AccessControl** de OpenZeppelin con tres roles principales:

### DEFAULT_ADMIN_ROLE
- Configurar registries (Identity, Trusted Issuers, Claim Topics)
- Pausar/despausar el token
- Gestionar roles (otorgar/quitar roles a otros)

### AGENT_ROLE
- **Mint** tokens nuevos
- **Burn** tokens existentes
- **Forced transfers** (bypass compliance)
- **Congelar/descongelar** cuentas

### COMPLIANCE_ROLE
- Agregar módulos de compliance
- Remover módulos de compliance
- Configurar módulos a través del ComplianceAggregator

---

## Características de Seguridad

### 1. Pausable

El admin puede pausar todas las transferencias en caso de emergencia:

```solidity
function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {
    _pause();
}
```

### 2. Congelación de Cuentas

Un agente puede congelar cuentas individuales:

```solidity
function freezeAccount(address account) external onlyRole(AGENT_ROLE) {
    frozen[account] = true;
    emit Frozen(account);
}
```

### 3. Transferencias Forzadas

Un agente puede forzar transferencias (útil para recuperación):

```solidity
function forcedTransfer(address from, address to, uint256 amount) 
    external onlyRole(AGENT_ROLE) {
    require(isVerified(to), "Recipient not verified");
    
    // Bypass compliance pero mantiene verificación de identidad
    bypassCompliance = true;
    _update(from, to, amount);
    bypassCompliance = false;
    
    // Notificar módulos
    for (uint256 i = 0; i < complianceModules.length; i++) {
        complianceModules[i].transferred(from, to, amount);
    }
}
```

---

## Diagrama de Arquitectura

```
┌────────────────────────────────────────────────────────┐
│                    TOKEN (ERC-3643)                    │
│  ┌──────────────────────────────────────────────────┐  │
│  │  • Extiende ERC-20                               │  │
│  │  • Access Control (Roles)                        │  │
│  │  • Pausable                                      │  │
│  │  • Frozen Accounts                               │  │
│  │  • Compliance Modules Array                      │  │
│  └──────────────────────────────────────────────────┘  │
└────────────────────────────────────────────────────────┘
         │                    │                    │
         │                    │                    │
    ┌────▼────┐         ┌────▼────┐         ┌────▼────┐
    │Identity │         │Trusted  │         │ Claim   │
    │Registry │         │Issuers  │         │ Topics  │
    │         │         │Registry │         │Registry │
    │ wallet →│         │         │         │         │
    │ identity│         │ issuer →│         │ topic[] │
    └────┬────┘         │ topics  │         └─────────┘
         │              └─────────┘
         │
    ┌────▼────┐
    │Identity │
    │Contract │
    │         │
    │ Claims: │
    │ • KYC   │
    │ • AML   │
    │ • etc.  │
    └─────────┘

┌────────────────────────────────────────────────────────┐
│              COMPLIANCE MODULES (Modular)              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │ MaxBalance   │  │ MaxHolders   │  │TransferLock  │  │
│  │ Compliance   │  │ Compliance   │  │ Compliance   │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
│                                                        │
│  • canTransfer() - Valida ANTES de transferir          │
│  • transferred() - Notifica DESPUÉS de transferir      │
│  • created() - Notifica cuando se mintean tokens       │
│  • destroyed() - Notifica cuando se queman tokens      │
└────────────────────────────────────────────────────────┘
```

---

## Flujo de Registro de un Nuevo Inversor

Para que un usuario pueda recibir tokens, debe seguir estos pasos:

### Paso 1: Desplegar Identity Contract
```solidity
Identity identity = new Identity(investorAddress);
```

### Paso 2: Registrar en IdentityRegistry
```solidity
identityRegistry.registerIdentity(investorAddress, address(identity));
```

### Paso 3: Agregar Claims al Identity
```solidity
identity.addClaim(
    topic,        // Ej: 1 = KYC
    scheme,       // Ej: 1 = ECDSA
    issuer,       // Dirección del emisor confiable
    signature,    // Firma del claim
    data,         // Datos del claim
    uri           // URI con información adicional
);
```

### Paso 4: Verificar que el Issuer es Confiable
El issuer debe estar registrado en `TrustedIssuersRegistry` y tener permiso para emitir el topic requerido.

### Paso 5: Verificar que el Topic es Requerido
El topic debe estar en `ClaimTopicsRegistry`.

**Una vez completados estos pasos, el usuario está "verificado" y puede recibir/transferir tokens.**

---

## Ejemplo Práctico: Transferencia de Tokens

### Escenario:
- Alice quiere transferir 100 tokens a Bob
- Ambos están verificados
- Token tiene 3 módulos de compliance activos

### Proceso:

1. **Alice llama:** `token.transfer(bob, 100)`

2. **Token ejecuta `_update()`:**
   - Llama `canTransfer(alice, bob, 100)`

3. **Validaciones en `canTransfer()`:**
   - ✅ Token no está pausado
   - ✅ Ni Alice ni Bob están congelados
   - ✅ Alice está verificada (tiene Identity con claims requeridos)
   - ✅ Bob está verificada (tiene Identity con claims requeridos)
   - ✅ MaxBalanceCompliance: Bob no excederá 1000 tokens
   - ✅ MaxHoldersCompliance: No se excederá el límite de holders
   - ✅ TransferLockCompliance: No hay bloqueo activo

4. **Si todas pasan:**
   - Se actualizan balances: `balanceOf[alice] -= 100`, `balanceOf[bob] += 100`
   - Se emite evento `Transfer(alice, bob, 100)`

5. **Notificación a módulos:**
   - `maxBalanceCompliance.transferred(alice, bob, 100)`
   - `maxHoldersCompliance.transferred(alice, bob, 100)`
   - `transferLockCompliance.transferred(alice, bob, 100)`

6. **Transferencia completada** ✅

---

## Resumen

ERC-3643 proporciona:

1. ✅ **Verificación de Identidad** - Solo usuarios verificados pueden operar
2. ✅ **Compliance Modular** - Reglas personalizables y combinables
3. ✅ **Control Administrativo** - Pausa, congelación, transferencias forzadas
4. ✅ **Seguridad** - Múltiples capas de validación
5. ✅ **Flexibilidad** - Módulos de compliance intercambiables

**Ideal para:** Tokenizar activos reales (RWA) con cumplimiento normativo on-chain, permitiendo control total sobre quién puede participar y cómo se pueden transferir los tokens.

---

## Referencias

- [ERC-3643 Standard](https://github.com/ethereum/EIPs/issues/3643)
- [T-REX Documentation](https://token-solutions.com/)
- [OpenZeppelin Contracts](https://docs.openzeppelin.com/contracts/)

---

**Última actualización:** 2024

