# EIP-1167: Minimal Proxy Contract (Clone Factory)

## ¿Qué es EIP-1167?

**EIP-1167** (Ethereum Improvement Proposal 1167) es un estándar para crear **Minimal Proxy Contracts**, también conocidos como **Clones**. Este patrón permite crear múltiples copias de un contrato de implementación de forma extremadamente eficiente en términos de gas.

### Concepto Clave

En lugar de desplegar un contrato completo cada vez que necesitas una nueva instancia, EIP-1167 permite crear un **proxy minimalista** que delega todas las llamadas al contrato de implementación original. El proxy solo almacena la dirección de la implementación y tiene su propio storage independiente.

---

## ¿Por qué usar EIP-1167?

### Ahorro Masivo de Gas

El principal beneficio es el **ahorro de gas**:

| Método | Gas Aproximado | Diferencia |
|--------|----------------|------------|
| Deployment directo | ~3,000,000 gas | - |
| Clone (EIP-1167) | ~55,000 gas | **~98% más barato** |

**Ejemplo del proyecto RWA:**
- Deployment directo de Token: ~3,736,079 gas
- Clone deployment: ~364,903 gas
- **Ahorro: 3,371,176 gas (90.2% de ahorro)**

### Casos de Uso Ideales

1. **Múltiples instancias del mismo contrato**
   - Crear muchos tokens similares
   - Crear múltiples pools de liquidez
   - Crear múltiples vaults o estrategias

2. **Reducción de costos en producción**
   - Cuando necesitas desplegar muchos contratos
   - Para permitir que usuarios creen sus propios contratos

3. **Estandarización**
   - Todos los clones usan la misma implementación
   - Facilita auditorías (solo auditar una implementación)
   - Actualizaciones centralizadas (si se usa con upgradeable pattern)

---

## ¿Cómo Funciona?

### Arquitectura del Patrón

```
┌─────────────────────────────────────────────────────────┐
│              IMPLEMENTATION CONTRACT                    │
│  ┌──────────────────────────────────────────────────┐  │
│  │  • Contiene toda la lógica                       │  │
│  │  • Se despliega UNA VEZ                          │  │
│  │  • Costo: ~3M gas                                │  │
│  │  • No almacena estado (o no se usa)              │  │
│  └──────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
                        ▲
                        │ delegatecall
                        │
         ┌──────────────┼──────────────┐
         │              │              │
    ┌────▼────┐   ┌────▼────┐   ┌────▼────┐
    │ Clone 1 │   │ Clone 2 │   │ Clone 3 │
    │         │   │         │   │         │
    │ Storage │   │ Storage │   │ Storage │
    │ Propio  │   │ Propio  │   │ Propio  │
    │         │   │         │   │         │
    │ Costo:  │   │ Costo:  │   │ Costo:  │
    │ ~55k    │   │ ~55k    │   │ ~55k    │
    │ gas     │   │ gas     │   │ gas     │
    └─────────┘   └─────────┘   └─────────┘
```

### Flujo de Ejecución

1. **Usuario llama a función en Clone:**
   ```solidity
   clone.transfer(to, amount)
   ```

2. **Clone recibe la llamada:**
   - El clone no tiene código propio
   - Solo tiene la dirección de la implementación

3. **Delegatecall a Implementation:**
   - El clone ejecuta `delegatecall(implementation, data)`
   - El código de la implementación se ejecuta
   - PERO el storage usado es del clone

4. **Resultado:**
   - Cada clone tiene su propio estado independiente
   - Todos comparten la misma lógica

---

## Estructura del Bytecode Minimal Proxy

El bytecode de un clone EIP-1167 es extremadamente pequeño (solo 55 bytes):

```
Bytecode (hex):
363d3d373d3d3d363d73[bebebebebebebebebebebebebebebebebebebe]5af43d82803e903d91602b57fd5bf3

Desglose:
- 363d3d373d3d3d363d73: Código de delegatecall
- [bebebebebebebebebebebebebebebebebebebe]: Dirección de implementación (20 bytes)
- 5af43d82803e903d91602b57fd5bf3: Código de retorno
```

### ¿Qué hace cada parte?

1. **Código de delegatecall**: Toma los datos de la llamada y los delega a la implementación
2. **Dirección de implementación**: La dirección del contrato que contiene la lógica
3. **Código de retorno**: Retorna el resultado de la llamada al caller original

---

## Implementación con OpenZeppelin

OpenZeppelin proporciona una librería `Clones` que facilita la creación de clones:

### Ejemplo Básico

```solidity
import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";

contract TokenFactory {
    using Clones for address;
    
    address public immutable implementation;
    
    constructor() {
        // Desplegar implementación UNA VEZ
        implementation = address(new TokenCloneable());
    }
    
    function createToken() external returns (address) {
        // Crear clone (muy barato en gas)
        address clone = implementation.clone();
        
        // Inicializar el clone
        TokenCloneable(clone).initialize(...);
        
        return clone;
    }
}
```

### Funciones de la Librería Clones

```solidity
// Crear un clone determinístico (misma dirección si mismo salt)
Clones.cloneDeterministic(implementation, salt)

// Calcular dirección de un clone determinístico
Clones.predictDeterministicAddress(implementation, salt, factory)

// Verificar si una dirección es un clone
Clones.isClone(implementation, query)
```

---

## Diferencias Clave: Constructor vs Initialize

### Contrato Normal (No Cloneable)

```solidity
contract Token {
    constructor(string memory name, string memory symbol) {
        _name = name;
        _symbol = symbol;
    }
}
```

**Problema:** Los constructores no se pueden llamar en clones. El constructor solo se ejecuta durante el deployment.

### Contrato Cloneable

```solidity
contract TokenCloneable {
    // Constructor vacío que deshabilita inicializadores
    constructor() {
        _disableInitializers();
    }
    
    // Función de inicialización
    function initialize(string memory name, string memory symbol) 
        external initializer {
        _name = name;
        _symbol = symbol;
    }
}
```

**Características:**
- Constructor vacío con `_disableInitializers()` para prevenir re-inicialización
- Función `initialize()` que puede ser llamada después del deployment
- Modificador `initializer` asegura que solo se llame una vez

---

## Ejemplo Completo del Proyecto RWA

### 1. Contrato Cloneable (TokenCloneable.sol)

```solidity
contract TokenCloneable is ERC20Upgradeable, AccessControlUpgradeable {
    // Constructor que deshabilita inicializadores
    constructor() {
        _disableInitializers();
    }
    
    // Función de inicialización (reemplaza constructor)
    function initialize(
        string memory name_,
        string memory symbol_,
        uint8 decimals_,
        address admin
    ) external initializer {
        __ERC20_init(name_, symbol_);
        __AccessControl_init();
        
        _grantRole(DEFAULT_ADMIN_ROLE, admin);
        _grantRole(AGENT_ROLE, admin);
    }
    
    // Resto de la lógica del contrato...
}
```

### 2. Factory Contract (TokenCloneFactory.sol)

```solidity
contract TokenCloneFactory is Ownable {
    using Clones for address;
    
    // Implementación que se clonará
    address public immutable implementation;
    
    constructor(address initialOwner) Ownable(initialOwner) {
        // Desplegar implementación UNA VEZ
        implementation = address(new TokenCloneable());
    }
    
    function createToken(
        string memory name_,
        string memory symbol_,
        uint8 decimals_,
        address admin
    ) external returns (address token) {
        // Crear clone (muy barato)
        token = implementation.clone();
        
        // Inicializar el clone
        TokenCloneable(token).initialize(name_, symbol_, decimals_, admin);
        
        return token;
    }
}
```

### 3. Uso del Factory

```solidity
// Desplegar factory (una vez)
TokenCloneFactory factory = new TokenCloneFactory(owner);

// Crear múltiples tokens (muy barato cada uno)
address token1 = factory.createToken("Token A", "TKA", 18, admin1);
address token2 = factory.createToken("Token B", "TKB", 18, admin2);
address token3 = factory.createToken("Token C", "TKC", 18, admin3);
```

---

## Ventajas del Patrón EIP-1167

### 1. Ahorro Masivo de Gas
- **~98% más barato** que deployment directo
- Ideal cuando necesitas crear muchos contratos

### 2. Estandarización
- Todos los clones comparten la misma implementación
- Facilita auditorías (solo auditar una vez)
- Comportamiento consistente

### 3. Mantenibilidad
- Código centralizado en un solo lugar
- Si necesitas actualizar lógica, puedes desplegar nueva implementación
- (Nota: Los clones existentes no se actualizan automáticamente)

### 4. Trazabilidad
- El factory puede mantener registro de todos los clones creados
- Facilita gestión y monitoreo

### 5. Flexibilidad
- Cada clone tiene su propio estado independiente
- Puedes configurar cada clone de forma diferente

---

## Desventajas y Limitaciones

### 1. No es Upgradeable
- Los clones NO se pueden actualizar automáticamente
- Si hay un bug, necesitas crear nuevos clones
- La implementación puede actualizarse, pero los clones existentes siguen usando la vieja

### 2. Pequeño Overhead
- Cada llamada tiene un pequeño overhead por el delegatecall
- Generalmente insignificante comparado con el ahorro de deployment

### 3. Dependencia de la Implementación
- Si la implementación se destruye (selfdestruct), todos los clones dejan de funcionar
- La implementación debe mantenerse viva

### 4. Complejidad Adicional
- Requiere entender delegatecall
- Requiere patrón de inicialización
- Puede ser confuso para desarrolladores nuevos

---

## Comparación con Otros Patrones

### EIP-1167 vs Deployment Directo

| Aspecto        | Deployment Directo | EIP-1167 Clone              |
|----------------|=-------------------|-----------------------------|
| Gas deployment | ~3M gas            | ~55k gas                    |
| Independencia  | ✅ Total           | ✅ Total                    |
| Upgradeable    | ❌ No              | ❌ No                       |
| Complejidad    | ✅ Simple          | ⚠️ Media                    |
| Trazabilidad   | ⚠️ Manual          | ✅ Automática (con factory) |

**Veredicto:** EIP-1167 es mejor cuando necesitas crear múltiples instancias.

### EIP-1167 vs Proxy Upgradeable (UUPS/Transparent)

| Aspecto        | EIP-1167             | Proxy Upgradeable          |
|----------------|----------------------|----------------------------|
| Gas deployment | ~55k gas             | ~200k gas                  |
| Upgradeable    | ❌ No                | ✅ Sí                      |
| Complejidad    | ⚠️ Media             | ⚠️ Alta                    |
| Uso            | Múltiples instancias | Contrato único upgradeable |

**Veredicto:** 
- EIP-1167 para múltiples instancias no upgradeables
- Proxy Upgradeable para un contrato que necesita actualizaciones

### EIP-1167 vs Beacon Proxy

| Aspecto         | EIP-1167                           | Beacon Proxy                                    |
|-----------------|------------------------------------|-------------------------------------------------|
| Gas deployment  | ~55k gas                           | ~200k gas                                       |
| Actualización centralizada| ❌ No                    | ✅ Sí                                           |
| Complejidad     | ⚠️ Media                           | ⚠️ Alta                                         |
| Caso de uso     | Múltiples instancias independientes| Múltiples instancias, actualización centralizada|

**Veredicto:** Beacon Proxy si necesitas actualizar todos los clones a la vez.

---

## Casos de Uso Reales

### 1. Token Factory (Como en el proyecto RWA)
```solidity
// Crear múltiples tokens de seguridad
factory.createToken("Real Estate Token", "RET", 18, admin);
factory.createToken("Art Token", "ART", 18, admin);
factory.createToken("Commodity Token", "COM", 18, admin);
```

### 2. Vault Factory
```solidity
// Crear múltiples vaults de inversión
factory.createVault(strategy1, admin1);
factory.createVault(strategy2, admin2);
```

### 3. Pool Factory
```solidity
// Crear múltiples pools de liquidez
factory.createPool(tokenA, tokenB, fee);
```

### 4. NFT Collection Factory
```solidity
// Crear múltiples colecciones NFT
factory.createCollection("Collection A", "CA", admin);
```

---

## Seguridad y Mejores Prácticas

### 1. Deshabilitar Inicializadores

```solidity
constructor() {
    _disableInitializers(); // Previene re-inicialización
}
```

### 2. Usar Modificador initializer

```solidity
function initialize(...) external initializer {
    // Solo se puede llamar una vez
}
```

### 3. Validar Parámetros

```solidity
function createToken(...) external {
    require(admin != address(0), "Invalid admin");
    require(bytes(name).length > 0, "Name required");
    // ...
}
```

### 4. Mantener Implementación Viva

- Nunca destruyas (selfdestruct) la implementación
- Asegúrate de que la implementación no tenga bugs críticos
- Considera hacer la implementación inmutable

### 5. Factory Ownership

- El factory puede tener un owner para control
- O puede ser sin owner si quieres que cualquiera pueda crear clones

---

## Gas Profiling

### Comparación Real del Proyecto RWA

```
┌─────────────────────────────────────────────────────────┐
│ Deployment Directo de Token                             │
├─────────────────────────────────────────────────────────┤
│ Constructor execution:        2,500,000 gas            │
│ Contract deployment:          1,236,079 gas            │
│ Total:                        3,736,079 gas            │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│ Clone Deployment (EIP-1167)                             │
├─────────────────────────────────────────────────────────┤
│ Clone creation:               45,000 gas                │
│ Initialize call:             319,903 gas                │
│ Total:                       364,903 gas                │
└─────────────────────────────────────────────────────────┘

Ahorro: 3,371,176 gas (90.2%)
```

### Análisis

- **Primera instancia:** Deployment directo cuesta más, pero no necesitas factory
- **Segunda instancia en adelante:** Clone es mucho más barato
- **Break-even:** Generalmente después de 1-2 clones, ya ahorras gas total

---

## Preguntas Frecuentes

### ¿Los clones comparten estado?

**No.** Cada clone tiene su propio storage completamente independiente. Solo comparten el código (lógica).

### ¿Puedo actualizar un clone?

**No directamente.** Los clones EIP-1167 no son upgradeables. Si necesitas actualizar, debes crear nuevos clones con la nueva implementación.

### ¿Qué pasa si destruyo la implementación?

**Todos los clones dejan de funcionar.** La implementación debe mantenerse viva para que los clones funcionen.

### ¿Puedo usar constructores en clones?

**No.** Los constructores solo se ejecutan durante el deployment. Los clones deben usar funciones `initialize()`.

### ¿Cuánto gas cuesta crear un clone?

**Aproximadamente 55,000 gas** para crear el clone, más el gas de la función `initialize()`.

---

## Recursos Adicionales

### Documentación Oficial
- [EIP-1167 Specification](https://eips.ethereum.org/EIPS/eip-1167)
- [OpenZeppelin Clones Documentation](https://docs.openzeppelin.com/contracts/4.x/api/proxy#Clones)

### Herramientas
- [Clone Address Calculator](https://eip1167.netlify.app/)
- [OpenZeppelin Contracts](https://github.com/OpenZeppelin/openzeppelin-contracts)

### Artículos
- [Understanding EIP-1167](https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/)
- [Gas Optimization with Clones](https://medium.com/coinmonks/gas-optimization-in-solidity-part-i-variables-9d5775e43dde)

---

## Resumen

**EIP-1167 Minimal Proxy** es un patrón extremadamente eficiente para crear múltiples instancias de contratos:

✅ **Ahorro de ~98% en gas** comparado con deployment directo  
✅ **Cada clone tiene estado independiente**  
✅ **Todos comparten la misma lógica** (implementación)  
✅ **Ideal para factories** que crean muchos contratos  
⚠️ **No es upgradeable** (por diseño)  
⚠️ **Requiere patrón de inicialización** (no constructores)  

**Ideal para:** Proyectos que necesitan crear múltiples instancias del mismo contrato, como tokens, vaults, pools, etc.

---

**Última actualización:** 2024

